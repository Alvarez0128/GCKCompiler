package AnalisisSintactico;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
}
:};

terminal tipoDato,array,object,rect2,vector2,timeSpan,resource,aabb,funcionInterna,const,importAll,mover,color,extendsP,new,return,startP,
         classP,void,print,func,for,while,if,elif,else,true,false,break,in,range,igual,masIgual,menosIgual,modIgual,porIgual,divIgual,notIgual,
         igualIgual,mayorIgual,menorIgual,menor,mayor,mas,mul,div,resta,mod,llave_A,llave_C,corch_A,corch_C,paren_A,paren_C,coma,and,or,not,opAccMiembros,
         cadChar,cadCaracteres,identificador,numEntero,numFloat,FinDeLinea
         ;

non terminal INICIO, SENTENCIA, DECLARACION, IF, ELIF,ELSE, WHILE, FOR,FUNCION,EXPRESION, BOOLEAN_EXPRESSION,BOOLEAN_TERM,BOOLEAN_LITERAL,BOOLEAN_FACTOR,PRIMARY,PARAMETRO,PARAMETROS,ELEMENTO,ELEMENTOS,DECCONST;

/* Precedencias y asociatividades */
precedence left mas, resta;
precedence left mul, div, mod;
precedence left or;
precedence left and;
precedence right not;

start with INICIO;

INICIO ::= 
   importAll
   classP identificador llave_A SENTENCIA llave_C
   |
   classP identificador llave_A SENTENCIA llave_C
;

SENTENCIA ::= 
   SENTENCIA DECLARACION |
   DECLARACION |
   SENTENCIA FUNCION |
   FUNCION |
   SENTENCIA IF | 
   IF |
   SENTENCIA ELIF |
   ELIF |
   SENTENCIA ELSE |
   ELSE |
   SENTENCIA WHILE
   WHILE |
   SENTENCIA FOR |
   FOR | 
   startP | /*empty*/
;

DECLARACION ::= 
   DECCONST tipoDato identificador FinDeLinea | 
   DECCONST tipoDato identificador igual EXPRESION FinDeLinea |
   DECCONST funcionInterna identificador FinDeLinea |
   DECCONST array corch_A tipoDato corch_C identificador igual corch_A ELEMENTOS corch_C FinDeLinea |
   DECCONST array corch_A tipoDato corch_C identificador igual corch_A corch_C FinDeLinea |
   DECCONST object identificador FinDeLinea |
   DECCONST object identificador igual paren_A PARAMETROS paren_C FinDeLinea |
   DECCONST rect2 identificador igual new rect2 paren_A identificador coma identificador paren_C FinDeLinea|
   DECCONST vector2 identificador igual new vector2 paren_A numEntero coma numEntero paren_C FinDeLinea |
   DECCONST timeSpan identificador igual new timeSpan paren_A numEntero paren_C FinDeLinea |
   DECCONST resource identificador igual llave_A cadCaracteres llave_C FinDeLinea |
   DECCONST aabb identificador igual new aabb paren_A identificador paren_C FinDeLinea |
   DECCONST color identificador igual paren_A numEntero coma numEntero coma numEntero paren_C FinDeLinea 
;

DECCONST::=
   const | /* VACIO */
;

EXPRESION ::=
   identificador | numEntero | numEntero| numFloat | cadCaracteres | cadChar | identificador | true | false |
   EXPRESION mas EXPRESION |
   EXPRESION resta EXPRESION |
   EXPRESION div EXPRESION |
   EXPRESION mul EXPRESION |
   EXPRESION mod EXPRESION |
   identificador igual EXPRESION |
   identificador masIgual EXPRESION |
   identificador menosIgual EXPRESION |
   identificador porIgual EXPRESION |
   identificador divIgual EXPRESION |
   identificador modIgual EXPRESION |
   paren_A EXPRESION paren_C;

FUNCION ::= func identificador paren_A PARAMETROS paren_C llave_A SENTENCIA llave_C
          | func identificador paren_A paren_C llave_A SENTENCIA llave_C
          | void func identificador paren_A PARAMETROS paren_C llave_A SENTENCIA llave_C
          | void func identificador paren_A paren_C llave_A SENTENCIA llave_C
;

PARAMETROS ::= PARAMETRO
             | PARAMETROS coma PARAMETRO
;

PARAMETRO ::= tipoDato identificador
           | tipoDato identificador coma PARAMETRO
;

ELEMENTOS ::= ELEMENTO
            | ELEMENTOS coma ELEMENTO
;

ELEMENTO ::= numEntero
           | numFloat
           | cadCaracteres
           | cadChar
           | identificador
           | true
           | false
;

IF ::= 
   if paren_A BOOLEAN_EXPRESSION paren_C llave_A SENTENCIA llave_C ELIF |
   if paren_A BOOLEAN_EXPRESSION paren_C llave_A SENTENCIA llave_C ELSE |
   if BOOLEAN_EXPRESSION llave_A SENTENCIA llave_C 
;

BOOLEAN_EXPRESSION ::= BOOLEAN_TERM
                     | BOOLEAN_EXPRESSION or BOOLEAN_TERM;

BOOLEAN_TERM ::= BOOLEAN_FACTOR
               | BOOLEAN_TERM and BOOLEAN_FACTOR;

BOOLEAN_FACTOR ::= PRIMARY
                 | not PRIMARY;

PRIMARY ::= BOOLEAN_LITERAL
         | paren_A BOOLEAN_EXPRESSION paren_C
         | PRIMARY igualIgual PRIMARY
         | PRIMARY notIgual PRIMARY
         | PRIMARY menor PRIMARY
         | PRIMARY menorIgual PRIMARY
         | PRIMARY mayor PRIMARY
         | PRIMARY mayorIgual PRIMARY
         | identificador opAccMiembros identificador 
         | identificador
;

BOOLEAN_LITERAL ::= true | false;

ELIF ::= elif paren_A BOOLEAN_EXPRESSION paren_C llave_A SENTENCIA llave_C 
       | elif paren_A BOOLEAN_EXPRESSION paren_C llave_A SENTENCIA llave_C ELIF
       | elif paren_A BOOLEAN_EXPRESSION paren_C llave_A SENTENCIA llave_C ELSE
       | /* empty */;

ELSE ::= else llave_A SENTENCIA llave_C | /* empty */;

WHILE ::= while paren_A BOOLEAN_EXPRESSION paren_C llave_A SENTENCIA break llave_C 
        | while BOOLEAN_EXPRESSION llave_A SENTENCIA break llave_C 
        | while paren_A BOOLEAN_EXPRESSION paren_C llave_A SENTENCIA llave_C 
        | while BOOLEAN_EXPRESSION llave_A SENTENCIA llave_C 
;

FOR ::= for identificador in range identificador llave_A SENTENCIA llave_C
      | for numEntero in range numEntero llave_A SENTENCIA llave_C
      | for identificador in range numEntero llave_A SENTENCIA llave_C
      | for numEntero in range identificador llave_A SENTENCIA llave_C

;

